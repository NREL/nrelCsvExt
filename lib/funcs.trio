// Copyright (C) 2017, National Renewable Energy Laboratory
// All Rights Reserved

---
name:csvImportSites
func
doc:
  Imports site records from CSV data. Intended for use in tailored CSV import scripts.

  Parameters
  ----------
  
  - **uri:** The URI of the file to read
  - **opts:** A dict of control options; see *Options*
  
  Returns
  -------
  
  A grid of imported site records.
  
  Options
  -------
  
  The following options are supported:
  
  - 'dryrun': Marker; if present then records will be read and returned but not committed to the
    Folio
  - 'flag': string specifying the name of a marker tag to apply to the new records as a flag
  - 'log': Boolean indicating whether log entries should be made for each imported record
  - 'template': A CSV template for supplemental columns; see `csvReadRecs`
  
  If supplied, 'template' will be merged with the default template (see *Details*). In the case of
  conflicts, the user-specified template entries take precedence.
  
  In addition, valid options for `csvReadRecs` may be supplied and will be passed through.
  
  Details
  -------
  
  This function expects a CSV file with some or all of the following columns:

    Tag         | Type    | Description
    ----------- | ------- | ------------------------------------------
    siteName    | string  | Name of site; converted to 'dis' tag
    siteTags    | taglist | Arbitrary list of tags to apply using Axon
    area        | number  | Area of site
    tz          | string  | String designation for site time zone
    geoAddr     | string  | Street address
    geoCity     | string  | City
    geoState    | string  | State / province
    geoCountry  | string  | Country code
    geoCoord    | coord   | Latitude/longitude in decimal format
    weatherName | string  | Weather location name; used to construct
                |         | 'weatherRef' by matching weather record
                |         | description
    weatherRef  | ref     | Weather location reference; silently
                |         | overrides 'weatherName'
    
  This default template can be modified using the 'template' option. Other arbitrary column names
  are also supported and will import as strings. See `csvReadRecs` for the low-level import
  function.
  
  Notes
  -----
  
  1. All imported sites receive the 'site' tag automatically. If an import 'flag' option is
     specified, imported sites receive it as a marker tag as well.
  2. All columns except 'siteName' are optional. 
  3. If the time zone 'tz' is missing, the new site will inherit the project's time zone.
     (Determining time zone based on location is not supported at this time.)
  4. Parsing failures will throw an error. In the event of a parsing failure, check the CSV data
     for errors.
src:
  (uri, opts:{}) => do

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // Setup
    //////////////////////////////////////////////////////////////////////////////////////////////////  

    // Default options
    opts = merge({log:true}, opts)
    
    // Tags to add
    addTags: {site}
    if (opts.has("flag")) addTags = addTags.set(opts->flag, marker())
    
    // CSV Template
    template: {
      siteName:"string",
      siteTags:"taglist",
      area:"number",
      geoAddr:"string",
      geoCity:"string",
      geoState:"string",
      geoCountry:"string",
      geoCoord:"coord",
      weatherRef:"ref",
      weatherName:"string"
    }
    if (opts.has("template")) template = merge(template, opts->template)

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    //////////////////////////////////////////////////////////////////////////////////////////////////
    
    // Add new record
    addRec: (msg, tags) => do

      // Remove null tags
      tags = tags.findAll v => v != null

      // Log an info message
      if (opts->log) logInfo("import", msg)

      // Add as new record to the database
      commit(diff(null, tags, {add}))
    end

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // Main
    //////////////////////////////////////////////////////////////////////////////////////////////////

    // Read from CSV
    d: csvReadRecs(uri, template, opts)

    // Process records and commit to database
    d.map() row => do
      // Add universal tags
      row = union(row, addTags)

      // Set site description
      row = row.set("dis", row["siteName"]).remove("siteName")

      // Set timezone (if missing)
      if (row.missing("tz")) row = row.set("tz", now().tz)

      // Map weather location
      if (row.has("weatherRef")) do
        weatherMatch: readById(row->weatherRef, false)
        if (weatherMatch == null) throw "Matching weather location record not found."
        row = row.remove("weatherName")
        
      end else if (row.has("weatherName")) do
        weatherMatch: readAll(weather and dis==row["weatherName"])
        if (weatherMatch.size != 1) do
          throw "Could not make a unique match for weather location " + row["weatherName"] +
            "; found " + weatherMatch.size + " records."
        else do
          row = row.set("weatherRef", weatherMatch.first->id).remove("weatherName")
        end
      end

      // Commit
      if (opts.has("dryrun")) do
        return row
      else do
        return addRec("Importing weather location " + row.dis, row)
      end
    end

  end
---
name:csvImportWeather
func
doc:
  Imports weather location records from CSV data. Intended for use in tailored CSV import scripts.

  Parameters
  ----------
  
  - **uri:** The URI of the file to read
  - **opts:** A dict of control options; see *Options*
  
  Returns
  -------
  
  A grid of imported weather location records.
  
  Options
  -------
  
  The following options are supported:
  
  - 'dryrun': Marker; if present then records will be read and returned but not committed to the
    Folio
  - 'flag': String specifying the name of a marker tag to apply to the new records as a flag
  - 'log': Boolean indicating whether log entries should be made for each imported record
  - 'template': A CSV template for supplemental columns; see `csvReadRecs`
  
  If supplied, 'template' will be merged with the default template (see *Details*). In the case of
  conflicts, the user-specified template entries take precedence.
  
  In addition, valid options for `csvReadRecs` may be supplied and will be passed through.
  
  Details
  -------
  
  This function expects a CSV file with some or all of the following columns:

    Tag         | Type   | Description
    ----------- | ------ | ------------------------------------------
    dis         | string | Name / label of weather location
    weatherTags | string | Arbitrary list of tags to apply using Axon
    geoCity     | string | City
    geoCoord    | coord  | Geographic coordinates
    geoState    | string | State / province
    geoCountry  | string | Country code
    tz          | string | String designation for location time zone
    
  This default template can be modified using the 'template' option. Other arbitrary column names
  are also supported and will import as strings. See `csvReadRecs` for the low-level import
  function.
  
  Notes
  -----
  
  1. All imported weather locations receive the 'weather' tag automatically. If an import 'flag'
     option is specified, imported weather locations receive it as a marker tag as well.
  2. All columns except 'dis' are optional, although SkySpark may fail to function properly if
     geographic location is not included.
  3. If the time zone 'tz' is missing, the new weather location will inherit the project's time
     zone. (Determining time zone based on location is not supported at this time.)
  4. Parsing failures will throw an error. In the event of a parsing failure, check the CSV data
     for errors.
src:
  (uri, opts:{}) => do

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // Setup
    //////////////////////////////////////////////////////////////////////////////////////////////////  

    // Default options
    opts = merge({log:true}, opts)

    // Tags to add
    addTags: {weather}
    if (opts.has("flag")) addTags = addTags.set(opts->flag, marker())

    // CSV Template
    // Template
    template: {
      dis:"string",
      weatherTags:"taglist",
      geoCity:"string",
      geoCoord:"coord",
      geoState:"string",
      geoCountry:"string"
    }
    if (opts.has("template")) template = merge(template, opts->template)

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    //////////////////////////////////////////////////////////////////////////////////////////////////

    // Add new record
    addRec: (msg, tags) => do

      // Remove null tags
      tags = tags.findAll v => v != null

      // Log an info message
      if (opts->log) logInfo("import", msg)

      // Add as new record to the database
      commit(diff(null, tags, {add}))
    end

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // Main
    //////////////////////////////////////////////////////////////////////////////////////////////////

    // Read from CSV
    d: csvReadRecs(uri, template, opts)
    
    // Process records and commit to database
    d.map() row => do
      // Add universal tags
      row = union(row, addTags)

      // Set timezone (if missing)
      if (row.missing("tz")) row = row.set("tz", now().tz)

      // Commit
      if (opts.has("dryrun")) do
        return row
      else do
        return addRec("Importing weather location " + row.dis, row)
      end
    end
    
  end
---
name:csvReadRecs
func
doc:
  Import records from CSV data using a flexible user-supplied template. This function is *not*
  designed to read and interpret [Haystack-compliant]`https://project-haystack.org/doc/Csv` CSV
  files, but rather to provide a flexible interface for pulling general purpose CSV data into
  Folio records.

  Parameters
  ----------
  
  - **uri:** The URI of the file to read
  - **template:** A dict specifying the data types for the CSV columns; see *Details*
  - **opts:** A dict of control options; see *Options*
  
  Returns
  -------
  
  A grid of dicts ready to commit as Folio records.
  
  Options
  -------
  
  The following options are supported:
  
  - 'delimiter': column delimiter character; passed through to `ioReadCsv`
  - 'noHeader': passed through to `ioReadCsv`
  - 'sep': tag and value separator to use for '"taglist"' and '"coord"' data types; see *Details*
  
  The default value of 'sep' is '" "', which maps to any whitespace character. 'sep' must differ
  from the column 'delimiter' (by default, '","') or parsing will fail.
  
  Details
  -------
  
  Use 'template' to specify how to interpret the CSV columns. In 'template', key names match to
  column names in the CSV file and key values are strings specifying a column data type. Supported
  data types are:
  
  - 'axon': parsed and executed as literal Axon code
  - 'bool': parsed as a boolean
  - 'coord': parsed as a coord; see below
  - 'date': parsed as a date
  - 'datetime': parsed as a dateTime
  - 'marker': any non-empty value is interpreted as setting a marker flag
  - 'number': parsed as a number
  - 'ref': parsed as a reference
  - 'string': parsed as a string
  - 'taglist': parsed as a tag list using Axon; see below
  
  Any other value in the template will throw an error when the corresponding column is parsed, while
  missing columns are parsed as strings by default. Data type values are not case sensitive.
  
  Coordinates ( '"coord"' data type) are processed using the `coord` function. The 'sep' option
  specifies the seperator between the two arguments of 'coord'. Similarly, tag lists ( '"taglist"'
  data type) are processed as dicts using Axon, with 'sep' interpreted as separating the tags in
  the dict. If needed in tag values, 'sep' can be protected by enclosing in quotes or escaping
  with '\'; see `delimConvert` for more information.
  
  Notes
  ------
  
  1. CSV column names should be valid tags, or parsing may fail.
  2. XStr and the Haystack collection data types (Dicts, Lists, and Grids) are not supported
     directly, but can be created indirectly via Axon code by specifying the '"axon"' data type in
     the template. If the Axon expression contains column delimiters, enclose it with quotes.
src:
  (uri, template:{}, opts:{}) => do

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Options
    ////////////////////////////////////////////////////////////////////////////////////////////////  
    
    // Default options
    opts = merge({sep:" "}, opts)
    
    // Valid pass-through options for ioReadCsv()
    ioOpts: opts.findAll() (v, n) => n.in(["delimiter", "noHeader"])
    
    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////
    
    // Parsing functions
    parseTags: (s) => delimConvert(s,opts->sep,",").stringToDict
    parseRef2: (r) => if (r.startsWith("@")) parseRef(r[1..-1]) else parseRef(r)
    parseCoord: (c) => eval("coord(" + delimConvert(c,opts->sep,",") + ")")

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Main
    ////////////////////////////////////////////////////////////////////////////////////////////////

    // Read and parse recs from file
    ioReadCsv(uri, ioOpts).map() row => do
      // Placeholder for output row
      tags: {}

      // Filter null and empty string input
      row = row.findAll() v => (v != null and v != "")

      // Parse tags
      row.each() (v,n) => do
        // Check for template
        if (template.has(n)) do
          if (template[n].lower == "axon") do
            tags = tags.set(n, eval(v))
          else if (template[n].lower == "bool") do
            tags = tags.set(n, parseBool(v))
          else if (template[n].lower == "coord") do
            tags = tags.set(n, parseCoord(v))
          else if (template[n].lower == "date") do
            tags = tags.set(n, parseDate(v))
          else if (template[n].lower == "datetime") do
            tags = tags.set(n, parseDateTime(v))
          else if (template[n].lower == "marker") do
            tags = tags.set(n, marker())
          else if (template[n].lower == "number") do
            tags = tags.set(n, parseNumber(v))
          else if (template[n].lower == "ref") do
            tags = tags.set(n, parseRef2(v))
          else if (template[n].lower == "string") do
            tags = tags.set(n, v)
          else if (template[n].lower == "taglist") do
            parseTags(v).each((vv,nn) => tags = tags.set(nn,vv))
          else do
            throw "Invalid field type for field " + n + ": " + template[n]
          end

        // No template; use as is
        else do
          tags = tags.set(n,v)
        end
      end

      // Return processed row of tags
      return tags
    end

  end
---
name:delimConvert
func
doc:
  In a string, convert instances of one delimiter to another. Converts instances of delimiter
  character 'old' in string 's' to 'new' (default '","'), under the following rules:
  
  - Delimiters inside quoted strings are ignored
  - Escaped delimiters (instances of 'old' prefixed by '\') are not converted, but the escape
    character '\' is stripped from the output
  - All other instances of 'old' are changed to 'new'
  - Consecutive delimiters are combined
  
  If 'old' is whitespace, then any whitespace character qualifies: space, '\t', '\n', '\r', '\f'.
  
  Examples
  --------

    "a b   c".delimConvert(" ")                     >> a,b,c
    "a;\"b;c\";c".delimConvert(";")                 >> a,"b;c",c
    "name:\"First Last\" age:34".delimConvert(" ")  >> name:"First Last",age:34
    r";\;".delimConvert(";", "|")                   >> |;
  
  Quotes omitted from outputs.
src:
  (s, old, new:",") => do
    // Check delimiter sizes
    if (old.size > 1 or new.size > 1) do
      throw "Old and new delimiters must each be a single character."
    end
    
    // Trivial case
    if (old == new) return s
    
    // Using a whitespace delimiter?
    oldIsSpace: old[0].isSpace
    
    // Setup (output buffer and flags)
    out: ""
    prev: null
    inQuotes: false
    
    // Scan and process input character-by-character
    (0..(s.size-1)).each() i => do
      // Get character
      char: s[i..i]
      
      // Switch...
      
      // Escape character: Buffer one only
      if (char == "\\") do
        if (prev == "\\") do
          out = out + prev
        end
      
      // Escaped quote
      end else if (char == "\"" and prev == "\\") do
        out = out + prev + char
        
      // Unescaped quote
      end else if (char == "\"") do
        inQuotes = not(inQuotes)
        out = out + char
        
      // Inside quotes: As-is
      end else if (inQuotes) do
        out = out + char
        
      // Escaped delimiter
      end else if (char == old and prev == "\\") do
        out = out + char
        
      // Unescaped delimiter
      end else if (char == old) do
        
        // Whitespace delimiter, non-consecutive: Replace
        if (oldIsSpace and not(prev[0].isSpace)) do
          out = out + new
        
        // Non-whitespace delimiter, non-consecutive: Replace
        else if (old != prev) do
          out = out + new
        
        // Consecutive delimiters: Skip (no action)
        end
        
      // All other characters
      end else do
        out = out + char
        
      end
      
      // Update
      prev = char
    end
    
    // Handle edge case: s ends in \
    if (s.endsWith("\\")) out = out + "\\"
    
    // Return
    return out
  end